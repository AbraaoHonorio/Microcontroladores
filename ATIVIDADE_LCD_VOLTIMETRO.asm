;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*              MODIFICAÇÕES PARA USO COM 12F675                   *
;*                FEITAS PELO PROF. MARDSON                        *
;*                    FEVEREIRO DE 2016                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       NOME DO PROJETO                           *
;*                           CLIENTE                               *
;*         DESENVOLVIDO PELA MOSAICO ENGENHARIA E CONSULTORIA      *
;*   VERSÃO: 1.0                           DATA: 17/06/03          *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     DESCRIÇÃO DO ARQUIVO                        *
;*-----------------------------------------------------------------*
;*   MODELO PARA O PIC 12F675                                      *
;*                                                                 *
;*                                                                 *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     ARQUIVOS DE DEFINIÇÕES                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
#INCLUDE <P12F675.INC>	;ARQUIVO PADRÃO MICROCHIP PARA 12F675

	__CONFIG _BODEN_OFF & _CP_OFF & _PWRTE_ON & _WDT_OFF & _MCLRE_ON & _INTRC_OSC_NOCLKOUT

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    PAGINAÇÃO DE MEMÓRIA                         *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;DEFINIÇÃO DE COMANDOS DE USUÁRIO PARA ALTERAÇÃO DA PÁGINA DE MEMÓRIA
#DEFINE	BANK0	BCF STATUS,RP0	;SETA BANK 0 DE MEMÓRIA
#DEFINE	BANK1	BSF STATUS,RP0	;SETA BANK 1 DE MAMÓRIA
#DEFINE	SRCLK	GPIO,GP0
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                         VARIÁVEIS                               *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DOS NOMES E ENDEREÇOS DE TODAS AS VARIÁVEIS UTILIZADAS 
; PELO SISTEMA

	CBLOCK	0X20	;ENDEREÇO INICIAL DA MEMÓRIA DE
					;USUÁRIO
		W_TEMP		;REGISTRADORES TEMPORÁRIOS PARA USO
		STATUS_TEMP	;JUNTO ÀS INTERRUPÇÕES
		TEMP
		TEMP_1
		ROTACIONAR
		;NOVAS VARIÁVEIS PARA CONVERSOR AD
		RESULTADO_0
		RESULTADO_1
		VALOR_1
		VALOR_2
		CONTADOR32
		VALORES
		CONTADOR_LOW
		CONTADOR_HIGH
		A0,B0,C0

	ENDC			;FIM DO BLOCO DE MEMÓRIA
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                        FLAGS INTERNOS                           *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS FLAGS UTILIZADOS PELO SISTEMA

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                         CONSTANTES                              *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODAS AS CONSTANTES UTILIZADAS PELO SISTEMA

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                           ENTRADAS                              *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO ENTRADA
; RECOMENDAMOS TAMBÉM COMENTAR O SIGNIFICADO DE SEUS ESTADOS (0 E 1)

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                           SAÍDAS                                *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO SAÍDA
; RECOMENDAMOS TAMBÉM COMENTAR O SIGNIFICADO DE SEUS ESTADOS (0 E 1)

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       VETOR DE RESET                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

	ORG	0X00			;ENDEREÇO INICIAL DE PROCESSAMENTO
	GOTO	INICIO
	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    INÍCIO DA INTERRUPÇÃO                        *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; ENDEREÇO DE DESVIO DAS INTERRUPÇÕES. A PRIMEIRA TAREFA É SALVAR OS
; VALORES DE "W" E "STATUS" PARA RECUPERAÇÃO FUTURA

	ORG	0X04			;ENDEREÇO INICIAL DA INTERRUPÇÃO
	MOVWF	W_TEMP		;COPIA W PARA W_TEMP
	SWAPF	STATUS,W
	MOVWF	STATUS_TEMP	;COPIA STATUS PARA STATUS_TEMP

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    ROTINA DE INTERRUPÇÃO                        *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; AQUI SERÁ ESCRITA AS ROTINAS DE RECONHECIMENTO E TRATAMENTO DAS
; INTERRUPÇÕES

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                 ROTINA DE SAÍDA DA INTERRUPÇÃO                  *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; OS VALORES DE "W" E "STATUS" DEVEM SER RECUPERADOS ANTES DE 
; RETORNAR DA INTERRUPÇÃO

SAI_INT
	SWAPF	STATUS_TEMP,W
	MOVWF	STATUS		;MOVE STATUS_TEMP PARA STATUS
	SWAPF	W_TEMP,F
	SWAPF	W_TEMP,W	;MOVE W_TEMP PARA W
	RETFIE

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*	            	 ROTINAS E SUBROTINAS                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; CADA ROTINA OU SUBROTINA DEVE POSSUIR A DESCRIÇÃO DE FUNCIONAMENTO
; E UM NOME COERENTE ÀS SUAS FUNÇÕES.

	
	
;FAZENDO OS DELAYS NECESSÁRIOS 
DELAY_17MS
	MOVLW	.70
	MOVWF 	TEMP
	MOVLW 	.14
	MOVWF 	TEMP_1
DELAY0_17MS
	DECFSZ	TEMP, F
	GOTO 	$+2
	DECFSZ 	TEMP_1, F
	GOTO	DELAY0_17MS

	GOTO	$+1
	NOP
	RETURN
	
;
DELAY_50US
	MOVLW	.15
	MOVWF	TEMP
DELAY0_50US
	DECFSZ	TEMP, F
	GOTO	DELAY0_50US
			
	GOTO	$+1

			
	RETURN
;	
DELAY_150US
	MOVLW	.48
	MOVWF	TEMP
DELAY0_150US
	DECFSZ	TEMP, F
	GOTO	DELAY0_150US
			
	GOTO	$+1
	
	RETURN
;
DELAY_6MS
	MOVLW	.174
	MOVWF 	TEMP
	MOVLW 	.5
	MOVWF 	TEMP_1
DELAY0_6MS
	DECFSZ	TEMP, F
	GOTO 	$+2
	DECFSZ 	TEMP_1, F
	GOTO	DELAY0_6MS

	GOTO	$+1
	NOP
	RETURN
;	
DELAY_2MS
	MOVLW	.142
	MOVWF 	TEMP
	MOVLW 	.2
	MOVWF 	TEMP_1
DELAY0_2MS
	DECFSZ	TEMP, F
	GOTO 	$+2
	DECFSZ 	TEMP_1, F
	GOTO	DELAY0_6MS

	GOTO	$+1
	NOP
	RETURN

DELAY_200MS
	DECFSZ	TEMP, F
	GOTO	$+2
	DECFSZ	TEMP_1, F
	GOTO	DELAY_200MS

			;2 CYCLES
	GOTO	$+1
; PULSANDO O CLOCK
PULSANDO_CLOCK 
	BSF SRCLK 
	BCF SRCLK
	RETURN
	
; ENVIA VALORES PARA INICIALIZAR A LCD
ENVIA_VALORES

	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB7
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB6
	CALL PULSANDO_CLOCK;
	BSF GPIO, GP4 ; ENVIANDO O VALOR DO DB5
	CALL PULSANDO_CLOCK;
	BSF GPIO, GP4 ; ENVIANDO O VALOR DO DB4
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ;  ENVIANDO O VALOR DO RS
	CALL PULSANDO_CLOCK;
	
	;ENVIANDO OS VALORES FAKE (PARA PODER ENVIAR OS 8BITS)
	BCF GPIO, GP4 
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 
	CALL PULSANDO_CLOCK;
	BSF GPIO, GP5; SETANDO O VALOR LCD_ENABLE
	BCF GPIO,GP5 ; LIMPANDO
	RETURN
	
; ENVIA TODOS VALORES  DA LINHA 1 E 2 DE ACORDO COM O PDF FLUXOGRAMA_INIT_LCD.PDF	
ENVIA_VALORES_1_2

	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB7
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB6
	CALL PULSANDO_CLOCK;
	BSF GPIO, GP4 ; ENVIANDO O VALOR DO DB5
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB4
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ;  ENVIANDO O VALOR DO RS
	CALL PULSANDO_CLOCK;
	
	;ENVIANDO OS VALORES FAKE (PARA PODER ENVIAR OS 8BITS)
	BCF GPIO, GP4 
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 
	CALL PULSANDO_CLOCK;
	BSF GPIO, GP5; SETANDO O VALOR LCD_ENABLE
	BCF GPIO,GP5 ; LIMPANDO
	RETURN
	
; ENVIA TODOS VALORES  DA LINHA 3 DE ACORDO COM O PDF FLUXOGRAMA_INIT_LCD.PDF	
ENVIA_VALORES_3_NF

	BSF GPIO, GP4 ; ENVIANDO O VALOR DO DB7
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB6
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB5
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB4
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ;  ENVIANDO O VALOR DO RS
	CALL PULSANDO_CLOCK;
	
	;ENVIANDO OS VALORES FAKE (PARA PODER ENVIAR OS 8BITS)
	BCF GPIO, GP4 
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 
	CALL PULSANDO_CLOCK;
	BSF GPIO, GP5; SETANDO O VALOR LCD_ENABLE
	BCF GPIO,GP5 ; LIMPANDO
	RETURN
	
; ENVIA TODOS O BIT 0
ENVIA_VALORES_SO_0

	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB7
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB6
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB5
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB4
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ;  ENVIANDO O VALOR DO RS
	CALL PULSANDO_CLOCK;
	
	;ENVIANDO OS VALORES FAKE (PARA PODER ENVIAR OS 8BITS)
	BCF GPIO, GP4 
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 
	CALL PULSANDO_CLOCK;
	BSF GPIO, GP5; SETANDO O VALOR LCD_ENABLE
	BCF GPIO,GP5 ; LIMPANDO
	RETURN
	
;LIGA DISPLAY	- SEM CURSOR
ENVIA_VALORES_5_LIGA_DISPLAY

	BSF GPIO, GP4 ; ENVIANDO O VALOR DO DB7
	CALL PULSANDO_CLOCK;
	BSF GPIO, GP4 ; ENVIANDO O VALOR DO DB6
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB5
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB4
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ;  ENVIANDO O VALOR DO RS
	CALL PULSANDO_CLOCK;
	
	;ENVIANDO OS VALORES FAKE (PARA PODER ENVIAR OS 8BITS)
	BCF GPIO, GP4 
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 
	CALL PULSANDO_CLOCK;
	BSF GPIO, GP5; SETANDO O VALOR LCD_ENABLE
	BCF GPIO,GP5 ; LIMPANDO
	RETURN
	
;LIMPA DISPLAY	
ENVIA_VALORES_7_LIMPA_DISPLAY

	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB7
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB6
	CALL PULSANDO_CLOCK;
	BSF GPIO, GP4 ; ENVIANDO O VALOR DO DB5
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB4
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ;  ENVIANDO O VALOR DO RS
	CALL PULSANDO_CLOCK;
	
	;ENVIANDO OS VALORES FAKE (PARA PODER ENVIAR OS 8BITS)
	BCF GPIO, GP4 
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 
	CALL PULSANDO_CLOCK;
	BSF GPIO, GP5; SETANDO O VALOR LCD_ENABLE
	BCF GPIO,GP5 ; LIMPANDO
	RETURN


ENVIA_VALORES_9

	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB7
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB6
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB5
	CALL PULSANDO_CLOCK;
	BSF GPIO, GP4 ; ENVIANDO O VALOR DO DB4
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ;  ENVIANDO O VALOR DO RS
	CALL PULSANDO_CLOCK;
	
	;ENVIANDO OS VALORES FAKE (PARA PODER ENVIAR OS 8BITS)
	BCF GPIO, GP4 
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 
	CALL PULSANDO_CLOCK;
	BSF GPIO, GP5; SETANDO O VALOR LCD_ENABLE
	BCF GPIO,GP5 ; LIMPANDO
	RETURN

; ENVIA CARACTER A CARACTER
ENVIA_CARACTER
	MOVWF ROTACIONAR
	RLF ROTACIONAR ; ROTACIONANDO O VALOR DO WORK
	BTFSC STATUS, C ; VERIFICANDO O VALOR DO C DO REGISTRADO STATUS É IGUAL 1, SE FOR 0 PULA 3 LINHAS
	GOTO $+4; PULA 4 LINHAS
	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB7
	CALL PULSANDO_CLOCK;
	GOTO $+3; PULA 3 LINHAS
	BSF GPIO, GP4 ; ENVIANDO O VALOR DO DB7
	CALL PULSANDO_CLOCK;
	
	RLF ROTACIONAR ; ROTACIONANDO O VALOR DO WORK
	BTFSC STATUS, C ; VERIFICANDO O VALOR DO C DO REGISTRADO STATUS É IGUAL 1, SE FOR 0 PULA 3 LINHAS
	GOTO $+4; PULA 4 LINHAS
	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB7
	CALL PULSANDO_CLOCK;
	GOTO $+3; PULA 3 LINHAS
	BSF GPIO, GP4 ; ENVIANDO O VALOR DO DB7
	CALL PULSANDO_CLOCK;
	
	RLF ROTACIONAR ; ROTACIONANDO O VALOR DO WORK
	BTFSC STATUS, C ; VERIFICANDO O VALOR DO C DO REGISTRADO STATUS É IGUAL 1, SE FOR 0 PULA 3 LINHAS
	GOTO $+4; PULA 4 LINHAS
	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB7
	CALL PULSANDO_CLOCK;
	GOTO $+3; PULA 3 LINHAS
	BSF GPIO, GP4 ; ENVIANDO O VALOR DO DB7
	CALL PULSANDO_CLOCK;
	
	RLF ROTACIONAR ; ROTACIONANDO O VALOR DO WORK
	BTFSC STATUS, C ; VERIFICANDO O VALOR DO C DO REGISTRADO STATUS É IGUAL 1, SE FOR 0 PULA 3 LINHAS
	GOTO $+4; PULA 4 LINHAS
	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB7
	CALL PULSANDO_CLOCK;
	GOTO $+3; PULA 3 LINHAS
	BSF GPIO, GP4 ; ENVIANDO O VALOR DO DB7
	CALL PULSANDO_CLOCK;
	
	;PULSO DE ENABLE
	BSF GPIO, GP4 ;  ENVIANDO O VALOR DO RS
	CALL PULSANDO_CLOCK;
	
	BSF GPIO, GP4 ;  ENVIANDO O VALOR DO RS
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ;  ENVIANDO O VALOR DO RS
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ;  ENVIANDO O VALOR DO RS
	CALL PULSANDO_CLOCK;
	
	BSF GPIO, GP5; SETANDO O VALOR LCD_ENABLE
	BCF GPIO,GP5 ; LIMPANDO
	
	RLF ROTACIONAR ; ROTACIONANDO O VALOR DO WORK
	BTFSC STATUS, C ; VERIFICANDO O VALOR DO C DO REGISTRADO STATUS É IGUAL 1, SE FOR 0 PULA 3 LINHAS
	GOTO $+4; PULA 4 LINHAS
	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB7
	CALL PULSANDO_CLOCK;
	GOTO $+3; PULA 3 LINHAS
	BSF GPIO, GP4 ; ENVIANDO O VALOR DO DB7
	CALL PULSANDO_CLOCK;
	
	RLF ROTACIONAR ; ROTACIONANDO O VALOR DO WORK
	BTFSC STATUS, C ; VERIFICANDO O VALOR DO C DO REGISTRADO STATUS É IGUAL 1, SE FOR 0 PULA 3 LINHAS
	GOTO $+4; PULA 4 LINHAS
	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB7
	CALL PULSANDO_CLOCK;
	GOTO $+3; PULA 3 LINHAS
	BSF GPIO, GP4 ; ENVIANDO O VALOR DO DB7
	CALL PULSANDO_CLOCK;
	
	RLF ROTACIONAR ; ROTACIONANDO O VALOR DO WORK
	BTFSC STATUS, C ; VERIFICANDO O VALOR DO C DO REGISTRADO STATUS É IGUAL 1, SE FOR 0 PULA 3 LINHAS
	GOTO $+4; PULA 4 LINHAS
	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB7
	CALL PULSANDO_CLOCK;
	GOTO $+3; PULA 3 LINHAS
	BSF GPIO, GP4 ; ENVIANDO O VALOR DO DB7
	CALL PULSANDO_CLOCK;
	
	RLF ROTACIONAR ; ROTACIONANDO O VALOR DO WORK
	BTFSC STATUS, C ; VERIFICANDO O VALOR DO C DO REGISTRADO STATUS É IGUAL 1, SE FOR 0 PULA 3 LINHAS
	GOTO $+4; PULA 4 LINHAS
	BCF GPIO, GP4 ; ENVIANDO O VALOR DO DB7
	CALL PULSANDO_CLOCK;
	GOTO $+3; PULA 3 LINHAS
	BSF GPIO, GP4 ; ENVIANDO O VALOR DO DB7
	CALL PULSANDO_CLOCK;
	
	;PULSO DE ENABLE
	BSF GPIO, GP4 ;  ENVIANDO O VALOR DO RS
	CALL PULSANDO_CLOCK;
	
	BSF GPIO, GP4 ;  ENVIANDO O VALOR DO RS
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ;  ENVIANDO O VALOR DO RS
	CALL PULSANDO_CLOCK;
	BCF GPIO, GP4 ;  ENVIANDO O VALOR DO RS
	CALL PULSANDO_CLOCK;
	
	BSF GPIO, GP5; SETANDO O VALOR LCD_ENABLE
	BCF GPIO,GP5 ; LIMPANDO
		
	RETURN
	

; --- FUNÇÃO DE DIVISÃO ---
DIVISAO

	CLRF		C0							;LIMPA REGISTRADOR C0
	
	
DIV_LOOP

	MOVF		B0,W						;COPIA DIVISOR PARA W
	SUBWF		A0,F						;SUBTRAI DIVISOR B0 DO DIVIDENDO A0
	BTFSS		STATUS,C					;TESTA PARA VER SE HOUVE CARRY
	GOTO		DIV_MENOR					;DIVIDENDO MENOR QUE ZERO, DESVIA PARA LABEL DIV_MENOR
	INCF		C0,F						;SE DIVIDENDO MAIOR QUE ZERO INCREMENTA O QUOCIENTE
	GOTO		DIV_LOOP					;RETORNA PARA NOVO CICLO DE SUBTRAÇÃO
	
DIV_MENOR
	MOVF		B0,W
	ADDWF		A0,F	
	;INCF		C0,F						;SE DIVIDENDO FOR MENOR OU IGUAL A ZERO, INCREMENTA QUOCIENTE
	RETURN									;RETORNA
	

	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     INICIO DO PROGRAMA                          *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	
INICIO
	BANK1				;ALTERA PARA O BANCO 1
	MOVLW	B'00001100'	;CONFIGURA TODAS AS PORTAS DO GPIO (PINOS)
	MOVWF	TRISIO		;COMO SAÍDAS, MENOS GP3(SEMPRE SAÍDA) E GP2(ENTRADA DE VALORES VINDO DA FONTE) 
	MOVLW	B'00000100'	;DEFINE GP2 COM ENTRADA ANALOGICA E FAZENDO USO DO 001 = FOSC/8
	MOVWF	ANSEL 		;DEFINE PORTAS COMO DIGITAL I/O
	MOVLW	B'00000100'
	MOVWF	OPTION_REG	;DEFINE OPÇÕES DE OPERAÇÃO
	MOVLW	B'00000000'
	MOVWF	INTCON		;DEFINE OPÇÕES DE INTERRUPÇÕES
	BANK0				;RETORNA PARA O BANCO
	MOVLW	B'00000111'
	MOVWF	CMCON		;DEFINE O MODO DE OPERAÇÃO DO COMPARADOR ANALÓGICO
	MOVLW	B'00001001'	;JUSTIFA A ESQUERDA, REF. EM VDD, HABILITA AN2,
	MOVWF	ADCON0		;LIGA A CONVERSÃO
	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     INICIALIZAÇÃO DAS VARIÁVEIS                 *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     ROTINA PRINCIPAL                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	; ESPERANDO 17 MS PARA PODER INICIALIZAR O LCD CORRETAMENTE
	
	;CORPO DA ROTINA PRINCIPAL
	CALL DELAY_17MS  ; AGUARDE PELO MENOS 15MS PARA GARANTIR O TÉRMINO DA OPERAÇÃO. PARA GARANTIR COLOQUEI 17MS
	;INICIALIZA O LCD -> ENVIE O COMANDO 0X30 PARA O DISPLAY
	CALL ENVIA_VALORES ; ENVIANDO OS VALORES RS=0 R/W=0 DB7=0 DB6=0 DB5=1 DB4=1
	
	CALL DELAY_6MS ; AGUARDE PELO MENOS 4.1MS PARA GARANTIR O TÉRMINO DA OPERAÇÃO. PARA GARANTIR COLOQUEI 6MS
	CALL ENVIA_VALORES ; ENVIANDO OS VALORES RS=0 R/W=0 DB7=0 DB6=0 DB5=1 DB4=1
	
	CALL DELAY_150US ;AGUARDE PELO MENOS 100ΜS. PARA GARANTIR COLOQUEI 150US
	CALL ENVIA_VALORES; ENVIANDO OS VALORES RS=0 R/W=0 DB7=0 DB6=0 DB5=1 DB4=1
	CALL DELAY_150US ;AGUARDE PELO MENOS 100ΜS. PARA GARANTIR COLOQUEI 150US
	
	CALL ENVIA_VALORES_1_2 ; ENVIANDO OS VALORES RS=0 R/W=0 DB7=0 DB6=0 DB5=1 DB4=0; - LINHA 1 
	CALL DELAY_150US ;AGUARDE PELO MENOS 100ΜS. PARA GARANTIR COLOQUEI 150US
	
	CALL ENVIA_VALORES_1_2 ; ENVIANDO OS VALORES RS=0 R/W=0 DB7=0 DB6=0 DB5=1 DB4=0; - LINHA 2 
	
	CALL ENVIA_VALORES_3_NF  ; ENVIANDO OS VALORES RS=0 R/W=0 DB7=1 DB6=0 DB5=0 DB4=0; - LINHA 3 
	CALL DELAY_150US ;AGUARDE PELO MENOS 100ΜS. PARA GARANTIR COLOQUEI 150US
	
	CALL ENVIA_VALORES_SO_0  ; ENVIANDO OS VALORES RS=0 R/W=0 DB7=0 DB6=0 DB5=0 DB4=0; - LINHA 4
	
	CALL ENVIA_VALORES_5_LIGA_DISPLAY  ; ENVIANDO OS VALORES RS=0 R/W=0 DB7=1 DB6=0 DB5=0 DB4=0; - LINHA 5 
	CALL DELAY_150US ;AGUARDE PELO MENOS 100ΜS. PARA GARANTIR COLOQUEI 150US

	CALL ENVIA_VALORES_SO_0 ; ENVIANDO OS VALORES RS=0 R/W=0 DB7=0 DB6=0 DB5=0 DB4=0; - LINHA 6
	CALL DELAY_50US ;AGUARDE PELO MENOS 40ΜS. PARA GARANTIR COLOQUEI 50US

	CALL ENVIA_VALORES_7_LIMPA_DISPLAY ; ENVIANDO OS VALORES RS=0 R/W=0 DB7=0 DB6=0 DB5=0 DB4=1; - LINHA 7
	CALL DELAY_2MS  ;AGUARDE PELO MENOS 2MS. 
	
	CALL ENVIA_VALORES_SO_0 ; ENVIANDO OS VALORES RS=0 R/W=0 DB7=0 DB6=0 DB5=0 DB4=0; - LINHA 8
	CALL DELAY_150US ;AGUARDE PELO MENOS 100ΜS. PARA GARANTIR COLOQUEI 150US
	
	CALL ENVIA_VALORES_9 ; ENVIANDO OS VALORES RS=0 R/W=0 DB7=0 DB6=0 DB5=0 DB4=1; - LINHA 9
	CALL DELAY_150US ;AGUARDE PELO MENOS 100ΜS. PARA GARANTIR COLOQUEI 150US
	
	CALL DELAY_6MS ; AGUARDE PELO MENOS 4.1MS PARA GARANTIR O TÉRMINO DA OPERAÇÃO. PARA GARANTIR COLOQUEI 6MS
	
	
MAIN 
	CALL ENVIA_VALORES_SO_0 ; ENVIANDO OS VALORES RS=0 R/W=0 DB7=0 DB6=0 DB5=0 DB4=0; - LINHA 6
	CALL DELAY_50US ;AGUARDE PELO MENOS 40ΜS. PARA GARANTIR COLOQUEI 50US
	CALL ENVIA_VALORES_7_LIMPA_DISPLAY ; ENVIANDO OS VALORES RS=0 R/W=0 DB7=0 DB6=0 DB5=0 DB4=1; - LINHA 7
	CALL DELAY_2MS  ;AGUARDE PELO MENOS 2MS. 
	CLRF	CONTADOR_LOW
	CLRF	CONTADOR_HIGH
	
 ; PEGAR OS 32 VALORES 
   MOVLW    .32
   MOVWF    CONTADOR32
   
    PEGA_32VALORES			
	CLRF	ADRESH		;LIMPA, PARA MEDIR DE NOVO A CADA VOLTA
	BSF	ADCON0, 1	;SOLICITA A CONVERÇÃO	
	BTFSC	ADCON0, 1	;ANALISANDO ATE PEGAR O VALOR
	GOTO	$-1
				
	MOVFW	ADRESH		;ENVIANDO O VALOR DO WORK PARA O ADRESH
	ADDWF	CONTADOR_LOW, 1	;PEGANDO OS 32 VALORES
	BTFSC	STATUS, C       ;TESTANDO SE HOUVE ESTOURO(CARRY ATIVO)
	INCF	CONTADOR_HIGH	;HOUVER CARRY,ENTÃO INCREMENTA EM 1
	DECFSZ	CONTADOR32, 1	;DECREMENTA O CONTADOR32 ATE SER ZERO
	GOTO	PEGA_32VALORES ;RETORNA
	
    ;CALCULAR O VALOR DA MÉDIA CONVERSÃO A/D USANDO 2 REGISTRADORES 
    
    ;ATENÇÃO IREMOS USAR DOIS REGRISTRADORES,'CONTINUA NA ABAIXO'
    ;PORQUE É IMPOSSIVEL CALCULAR O VALOR MÁXIMO COM APENAS 1 REGISTRADO
    ;COMO O MÁXIMO PERMITIDO É 8160(255 * 32) , OU SEJA, 'CONTINUA NA ABAIXO'
    ;0001111111100000 (BINÁRIO), COM ISSO IREMOS ROTACIONAR OS 5 BITS (CONTINUA)
    ; MENOS SIGNIFICATIVO  DO REGISTRADOR HIGH(CONTADOR_HIGH)..
    ;DO CONTADOR_HIGH NOS 5 BITS MAIS SIGNFICATIVO DO CONTADOR_LOW
    ;COMO 32 É MULTIPLO DE 2, OU SEJA 32 É IGUAL A 2^5, 'CONTINUA NA ABAIXO'
    ;A CADA ROTAÇÃO PARA ESQUERDA É COMO SE TIVESSEMOS DIVIDINDO POR 2
    ;LOGO, É POSSÍVEL CALCULAR A MÉDIA ROTACIONANDO REGISTRADOR 5 VEZES! 
  
	; ROTAÇÃO DO LOW E ; ROTAÇÃO DO HIGH
	RRF  CONTADOR_HIGH  ; PRIMEIRA DIVISÃO, OU SEJA, PRIMEIRA ROTAÇÃO
	RRF  CONTADOR_LOW   ; PRIMEIRA DIVISÃO, OU SEJA, PRIMEIRA ROTAÇÃO
	RRF  CONTADOR_HIGH  ; SEGUNDA  DIVISÃO, OU SEJA, SEGUNDA ROTAÇÃO
	RRF  CONTADOR_LOW   ; SEGUNDA DIVISÃO, OU SEJA, SEGUNDA ROTAÇÃO
	RRF  CONTADOR_HIGH  ; TERCEIRA DIVISÃO, OU SEJA, TERCEIRA ROTAÇÃO
	RRF  CONTADOR_LOW   ; TERCEIRA DIVISÃO, OU SEJA, TERCEIRA ROTAÇÃO
	RRF  CONTADOR_HIGH  ; QUARTA DIVISÃO, OU SEJA, QUARTA ROTAÇÃO
	RRF  CONTADOR_LOW   ; QUARTA DIVISÃO, OU SEJA, QUARTA ROTAÇÃO
	RRF  CONTADOR_HIGH  ; QUINTA DIVISÃO, OU SEJA, QUINTA ROTAÇÃO
	RRF  CONTADOR_LOW   ; QUINTA DIVISÃO, OU SEJA, QUINTA ROTAÇÃO
	

	; CALCULANDO A REGRA DE 3
	CLRF	    CONTADOR_HIGH ; LIMPANDO O REGISTRADOR CONTADOR_HIGH
	MOVLW	    .100	 ;CARREGA 100 EM WORK
 	MOVWF	    VALOR_1	 ;VALOR_1 = 100
	MOVFW	    CONTADOR_LOW ;CARREGA NÚMERO EM WORK
	
	; FUNCAO DE MULTIPLICAÇÃO
	MULTIPLICACAO			
	   ADDWF	CONTADOR_LOW, F ;SOMANDO O CONTADOR_LOW 100 VEZES
	   BTFSC	STATUS, C       ;TESTANDO SE HOUVE ESTOURO(CARRY ATIVO)
	   INCF		CONTADOR_HIGH	;HOUVER CARRY,ENTÃO INCREMENTA EM 1
	   DECFSZ	VALOR_1, 1	;DECREMENTA O CONTADOR32 ATE SER ZERO
	   GOTO	MULTIPLICACAO		;RETORNA
	
	;DIVIDINDO OS DEZENA E UNIDADE 
	MOVFW		CONTADOR_HIGH						;CARREGA NÚMERO EM W
 	MOVWF		A0							;A0 = NÚMERO
 	MOVLW		.10						;CARREGA NÚMERO EM W
 	MOVWF		B0							;B0 = NÚMERO
 	CALL		DIVISAO							;CHAMA SUB-ROTINA DE MULTIPLICAÇÃO
 	
	; TESTANDO SE A DEZENA TEM 2 DIGITOS, SE SIM ENVIA 10(2 DIGÍTOS)
	; SENÃO PULA PARA IMPRIMIR_UNIDADE
	MOVLW   .0
	SUBWF	C0,W
	BTFSC	STATUS,Z 
	GOTO	IMPRIMIR_UNIDADE
	
	; TESTANDO SE O VALOR ENVIADO É 10(2 DIGÍTOS)
	MOVLW   .10
	SUBWF	C0,W
	BTFSC	STATUS,Z 
	GOTO	IMPRIMIR_VALOR_10
	
	MOVLW	H'30'
	ADDWF	C0, F ;ADICIONANDO 30 EM HEXA
	MOVFW C0
	CALL  ENVIA_CARACTER
	CALL DELAY_150US ;AGUARDE PELO MENOS 100ΜS. PARA GARANTIR COLOQUEI 150US
	
	GOTO IMPRIMIR_UNIDADE
	
	IMPRIMIR_VALOR_10
	MOVLW	H'31'
	CALL  ENVIA_CARACTER
	CALL DELAY_150US ;AGUARDE PELO MENOS 100ΜS. PARA GARANTIR COLOQUEI 150US
	MOVLW	H'30'
	CALL  ENVIA_CARACTER
	CALL DELAY_150US ;AGUARDE PELO MENOS 100ΜS. PARA GARANTIR COLOQUEI 150US
	
	
	IMPRIMIR_UNIDADE
	MOVLW		H'30'
	ADDWF	A0, F ;ADICIONANDO 30 EM HEXA
	MOVFW A0
	CALL  ENVIA_CARACTER
	CALL DELAY_150US ;AGUARDE PELO MENOS 100ΜS. PARA GARANTIR COLOQUEI 150US

	
	MOVLW	H'25' ; ENVIA O CARACTER %
	CALL  ENVIA_CARACTER
	CALL DELAY_150US ;AGUARDO O TEMPO
	
	MOVLW	H'20'
	CALL  ENVIA_CARACTER
	CALL DELAY_150US ;AGUARDO O TEMPO
	MOVLW	H'20'
	CALL  ENVIA_CARACTER
	CALL DELAY_150US ;AGUARDO O TEMPO
	
	CALL DELAY_200MS ;;*TODO* ATUALIZAR O DISPLAY 200MS
	GOTO MAIN 

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       FIM DO PROGRAMA                           *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

	END